"""
Main API server for Meal Planner Agent System

This server handles:
1. Recipe Agent - Receives preferences, returns recipes with ingredients and nutrition
2. Shopping & Budget Agent - Receives ingredients, returns shopping list
3. Health Agent - Receives nutritional info (work in progress)
"""

import sys
import os
import asyncio
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
import uvicorn

# Add agents directory to path
sys.path.append(os.path.join(os.path.dirname(__file__), "agents"))

# Import orchestrator and agents
from orchestrator import (
    run_meal_planner_workflow,
    orchestrator_runner,
    memory_service,
    session_service,
    APP_NAME
)
from agents.recipe_agent import recipe_agent, RecipeAgentRunner
from agents.shopping_budget_agent import ShoppingBudgetAgent
from agents.preference_agent import preference_agent, PreferenceAgentRunner
from agents.health_agent import HealthAgent

app = FastAPI(
    title="Meal Planner Agent API",
    description="API for Recipe, Shopping & Budget, and Health Agents using Sequential Agent Orchestration",
    version="2.0.0"
)

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Keep legacy agent runners for individual endpoints (backward compatibility)
recipe_runner = RecipeAgentRunner(recipe_agent)
shopping_agent = ShoppingBudgetAgent(currency="INR")
preference_runner = PreferenceAgentRunner(preference_agent)
health_agent = HealthAgent()

# =========================
#   REQUEST/RESPONSE MODELS
# =========================

class PreferenceRequest(BaseModel):
    """Request model for recipe preferences"""
    dietary_restrictions: Optional[List[str]] = []
    cuisine_preferences: Optional[List[str]] = []
    meal_type: str = "dinner"
    servings: int = 4
    budget_per_meal: Optional[float] = None


class RecipeResponse(BaseModel):
    """Response model for recipe data"""
    recipe_name: str
    description: str
    ingredients: Dict[str, List[str]]
    instructions: List[Dict[str, Any]]
    nutritional_information: Dict[str, Any]


class IngredientsRequest(BaseModel):
    """Request model for shopping & budget agent"""
    recipe_name: str
    ingredients: Dict[str, List[str]]
    budget: Optional[float] = 500.0
    stores: Optional[List[str]] = ["Amazon", "Flipkart", "LocalStore"]


class NutritionRequest(BaseModel):
    """Request model for health agent"""
    recipe_name: str
    nutritional_information: Dict[str, Any]


class UserPreferenceInput(BaseModel):
    """Request model for user preference description"""
    user_description: str
    user_id: Optional[str] = "user_001"


class UserProfileResponse(BaseModel):
    """Response model for user health profile"""
    diet_type: str
    daily_calorie_target: int
    protein_target_g: int
    carb_target_g: int
    fat_target_g: int
    meals_per_day: int
    allergies: List[str]
    dislikes: List[str]
    health_notes: List[str]

# =========================
#   COMBINED WORKFLOW ENDPOINT
# =========================

@app.post("/complete-meal-plan")
async def complete_meal_plan_workflow(preference_input: UserPreferenceInput):
    """
    üåü COMPLETE WORKFLOW using Sequential Agent Orchestrator
    
    This endpoint uses SequentialAgent to automatically chain:
    Preference Agent ‚Üí Recipe Agent ‚Üí Shopping Agent ‚Üí Health Analysis
    
    Args:
        preference_input: User's natural language description and user_id
    
    Returns:
        Complete meal plan generated by the orchestrator
    """
    try:
        # Use the orchestrator for streamlined workflow
        result = await run_meal_planner_workflow(
            user_description=preference_input.user_description,
            user_id=preference_input.user_id,
            budget=500.0
        )
        
        if not result.get("success"):
            raise HTTPException(
                status_code=500,
                detail=result.get("error", "Unknown error in workflow")
            )
        
        return {
            "success": True,
            "workflow_type": "Sequential Agent Orchestration",
            "user_id": result.get("user_id"),
            "session_id": result.get("session_id"),
            "meal_plan": result.get("response"),
            "message": "Complete meal plan generated using Sequential Agent workflow"
        }
    
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error in Sequential Agent workflow: {str(e)}"
        )


# =========================
#   HEALTH CHECK ENDPOINT
# =========================

@app.get("/")
async def root():
    """Health check and API information"""
    return {
        "status": "ok",
        "service": "Meal Planner Agent API",
        "version": "2.0.0",
        "architecture": "Sequential Agent Orchestration",
        "workflow": "Preference ‚Üí Recipe ‚Üí Shopping ‚Üí Health",
        "endpoints": {
            "üåü main_workflow": {
                "POST /complete-meal-plan": "Full Sequential Agent workflow (recommended)"
            },
            "memory": {
                "POST /memory/save-session": "Save session to memory",
                "POST /memory/search": "Search stored memories",
                "GET /memory/stats": "Memory statistics"
            }
        },
        "message": "Use /docs for interactive API documentation"
    }

# =========================
#   SERVER STARTUP
# =========================

if __name__ == "__main__":
    print("üöÄ Starting Meal Planner Agent API (v2.0)...")
    print("üåê Server running at: http://localhost:8000")
    print("üìö API Docs at: http://localhost:8000/docs")
    print("üìä Health check: http://localhost:8000/\n")
    
    uvicorn.run(app, host="0.0.0.0", port=8000)